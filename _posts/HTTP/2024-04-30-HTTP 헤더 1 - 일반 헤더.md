---
title: "[HTTP] 7. HTTP 헤더1 - 일반 헤더"
categories:
  - HTTP
tags:
toc: true
toc_sticky: true
date: 2024-04-30 23:40:00 +0900
---

<strong>모든 개발자를 위한 HTTP 웹 기본 지식 (김영한) 강의 수강 후 정리한 자료입니다.</strong>
{: .notice}

# ❗HTTP 메시지 헤더에 대해 알아보자❗

## ✨ HTTP 헤더

- 필드 네임은 대소문자 구분 없음
- 용도 : HTTP 전송에 필요한 모든 부가 정보

과거에는 엔티티라는 표현으로 바디와 헤더를 구분했지만, 현재는 엔티티가 `표현`으로 대체됨

### HTTP Body 최신 스펙

- 메시지 본문을 통해 표현 데이터 전달
- 메시지 본문 = 페이로드
- 표현은 요청이나 응답에서 전달할 실제 데이터를 의미함
  - 데이터 유형이 다양하기 때문에, "표현"이라는 용어를 사용함
  - 데이터 유형(html, json), 데이터 길이, 압축 정보 등
- cf) 표현 헤더는 표현 메타데이터와 페이로드 메시지를 구분해야 하지만, 대부분 생략함

## ✨ 표현

표현 데이터는 전송, 응답 둘다 사용

### Content-Type

: 표현 데이터의 형식

- 미디어, 타입, 문자 인코등
  <br /> ex) text/html; charset=utf-8, application/json, image/png

### Content-Encoding

: 표현 데이터의 압축 방식

- 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
- 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
  <br/> -> ex) gzip, deflate, identity (압축 X)

### Content-Language

: 표현 데이터의 자연 언어

- 공식 사이트에서 보고 싶은 언어로 선택할 때 사용할 수 있음 (영어로 되어 있는 공식 사이트를 한국어로 보고 싶다고 선택)
  <br /> ex) ko, en, en-US

### Content-Length

: 표현 데이터의 길이

- 바이트 단위
- Transfer-Encoding(전송 코딩) 을 사용하면 Content-Length를 사용하면 안 됨.

## ✨ 콘텐츠 협상

### 협상 (콘텐츠 네고시에이션)

: 클라이언트가 선호하는 표현 요청

- 협상 헤더는 요청 시에만 사용
- 몇 번의 번거로운 과정을 생략할 수 있음
  <br /> ex) 한국어 브라우저에서 요청 -> 서버에서는 한국어인지 영어인지 모르니까 기본 언어인 영어로 응답 -> 한국어로 재요청
  => 한국어로 요청 -> 한국어로 응답

그런데 한국어 브라우저에서 한국어로 요청했는데 서버에서는 독일어와 영어만 지원한다면?

이를 해결해 줄 수 있는 방법이 `우선순위`

### 협상과 우선순위1

- Quality Value(q) 값 사용
- 0 ~ 1, 클수록 높은 우선순위
- 생략하면 1
  <br /> ex) Accept-Language: ko-KR,ko;q=0.9,en-US;q-0.8,en;q=0.7

### 협상과 우선순위2

- 구체적인 것이 우선
  ex) Accept: text/\*, text/plain, text/plain;format-flowed, \*/\*
  1. text/plain;format-flowed
  2. text/plain
  3. text/\*
  4. \*/\*

### 협상과 우선순위3

구체적인 것을 기준으로 미디어 타입을 맞춤

Accept Media Type에 이미 Quality 기준이 나와 있음. 그것에 따라 우선 순위를 선별

- Accept : 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset : 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
- Accept-Language : 클라이언트가 선호하는 자연 언어

## ✨ 전송 방식

### 단순 전송

- Content-Length 지정
- 한 번에 요청하고 한 번에 받음

### 압축 전송

- 서버에서 압축
- Content-Encoding을 추가로 넣어줘야 함

### 분할 전송

- Transfer-Encoding: chunked 사용
- 큰 용량을 쪼개어, 여러 번에 나누어 전송
- Content-Length를 넣으면 안 됨. 길이 예측이 불가능하기 때문

ex)

5<br />hello<br />5<br />hello2<br/>0<br/>\r\n
<br /> -> 5바이트 hello 전송, 5바이트 hello2 전송
<br /> -> 끝을 나타낼 때는 0, \r\n으로 표시

### 범위 전송

- Content-Range 사용
- 다운받다가 끊긴 부분이 있으면 (ex, 이미지) 나머지 부분만 다시 요청하는 경우 사용할 수 있음
  <br /> ex) Content-Range: bytes 1001-2000 / 2000

## ✨ 헤더 정보

### From

: 유저 에이전트의 이메일 정보

- 일반적으로 잘 사용되지 않음
- 검색 엔진 같은 곳에서 주로 사용
- 요청에서 사용
- 크롤링할 때 우리 정보 사용하지 마라, 등의 연락 수단으로 사용이 가능하다

### Referer

: 이전 웹 페이지 주소

- 많이 사용됨
- 현재 요청된 페이지의 이전 웹 페이지 주소
- Referer을 사용해 유입 경로 분석 가능
- 요청에서 사용
  <br /> cf) referer은 referrer의 오타
  <br /> ex) 구글에서 hello 검색, hello 검색된 창에서 referer을 보면 구글로 되어 있음. 왜? 구글에서 들어왔으니까.

### User-Agent

: 유저 에이전트 애플리케이션 정보

- 내 웹 브라우저 정보
- 통계 정보
- 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능 (로그 비교, 특정 브라우저에서 문제가 생기는지 파악 가능)
- 요청에서 사용

### Server

: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

- ORIGIN 서버 : 요청을 보내면 여러 프록시 서버를 거치게 됨. 진짜 나의 요청이 있는, 최종 응답 서버를 ORIGIN 서버라고 함.
- 응답에서 사용

### Date

: 메시지가 생성된 날짜

- 응답에서 사용

### Host

: 요청한 호스트 정보 (도메인)

- 요청에서 사용
- 필수
- 하나의 서버가 여러 도메인을 처리해야 할 때
- 하나의 IP 주소에 여러 도메인이 적용되어 있을 때
  <br /> -> 하나의 서버에 여러 개의 애플리케이션이 가동되고 있을 수도 있다
  <br /> -> host가 없는 경우 서버의 어떤 애플리케이션으로 통신해야하는지 모름. 따라서 host 헤더를 무조건 넣어야 한다고 개정됨.

### Location

: 페이지 리다이렉션

- 웹 브라우저는 3XX 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동 (리다이렉트)
- 201 (Created) : Location 값은 요청에 의해 생성된 리소스 URI
- 3XX (Redirection) : Location 값은 요청을 자동으로 리다이렉션하기 위한 대상 리소스를 가리킴.

### Allow

: 허용 가능한 HTTP 메서드

- 405 (Method Not Allowed) 에서 응답에 포함해야 함.
  <br /> ex) URL 경로는 있는데 POST는 제공 안 함. HTTP 메서드는 GET, HEAD, PUT만 지원합니다.
- 자주 쓰이지는 않음

### Retry-After

: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

- 503 (Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음
- 날짜 표기 or 초단위 표기

## ✨ 인증

- Authorization : 클라이언트 인증 정보를 서버에 전달
  <br /> -> OAuth 인증 등 메커니즘마다 value 값이 다름.
  <br /> -> 어떤 값이든지 헤더를 제공하는 것이 HTTP Authorization
- WWW-Authenticate : 리소스 접근 시 필요한 인증 방법 정의
  <br /> -> 401 Unauthorized 응답과 함께 사용

## ✨ 쿠키

- Set-Cookie 서버에서 클라이언트로 쿠키 전달 (응답)
- Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청 시 서버로 전달

### 사용

- 사용자 로그인 세션 관리
- 광고 정보 트래킹

### 문제와 해결

Stateless이기 때문에 인증된 사용자인지 아닌지 확인이 불가능함. (무상태 프로토콜)
<br /> cf) [[HTTP] 3. HTTP 기본](https://ajung7038.github.io/http/HTTP-%EA%B8%B0%EB%B3%B8/)

모든 요청에 정보를 보내는 것은? 비효율적이며, 보안 문제도 있음.

이를 해결하기 위해 "쿠키"를 사용함.

1. 웹 브라우저에서 정보를 넘김 -> 로그인
2. Set-Cookie를 사용해 (쿠키 헤더) 정보를 응답
3. 웹 브라우저 내부의 쿠키 저장소에 서버에서 보낸 응답(쿠키) 저장
4. 웹 브라우저에 접속하면 쿠키 저장소에서 조회해 유저 대조 및 확인

모든 요청에 쿠키 정보를 자동 포함

그렇지만 모든 요청에 쿠키 정보를 담게 되면 보안 상의 문제가 발생할 수도 있다.

발생하는 문제는 다음과 같다.

- 네트워크 트래픽 추가 유발
- 최소한의 정보만 사용 (세션 id, 인증 토큰)
- 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지 (localStorage, sessionStorage) 참고

<strong>보안에 민감한 데이터는 저장하면 안 됨 (주민번호, 신용카드 등등) </strong>

{: .notice--danger}

### 생명주기

ex) Set-Cookie: expires=Sat, 26,Dec-2024 04:39:21 GMT

- 만료일이 되면 쿠키 삭제
- GMT 기준(그리니치 평균 시간)으로 넣어줘야 함.

<br/> ex) Set-Cookie: max-age=3600(3600초)

- 0이나 음수를 지정하면 쿠키 삭제

### 종류

- 세션 쿠키 : 만료 날짜를 생략하면 브라우저 종료시까지만 유지
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지

### 쿠키 - 도메인

ex) domain=example.org

- 명시한 문서 기준 도메인 + 서브 도메인 포함
  <br />-> example.org, dev.example.org 모두 쿠키 접근 가능
- 생략 : 현재 문서 기준 도메인만 적용
  <br />-> example.org만 가능, dev.example.org는 쿠키 미접근

### 쿠키 - Path

- 경로를 포함한 하위 경로 페이지만 쿠키 접근
- 보통 루트 경로로 접근 (path=/)

### 쿠키 - 보안

#### Secure

- 원래는 http, https 구분하지 않고 전송
- Secure을 적용하게 되면 https인 경우에만 전송

#### HttpOnly

- XSS 공격 방지
- 자바스크립트에서 접근 불가 (document.cookie)
- HTTP 전송에만 사용

#### SameSite

- XSRF 공격 방지
- 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송
