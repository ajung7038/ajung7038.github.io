---
title: "[HTTP] 8. HTTP 헤더1 - 캐시와 조건부 요청"
categories:
  - http
tags:
toc: true
toc_sticky: true
date: 2024-05-05 12:26:00 +0900
---

<strong>모든 개발자를 위한 HTTP 웹 기본 지식 (김영한) 강의 수강 후 정리한 자료입니다.</strong>
{: .notice}

# ❗캐시와 조건부 요청에 대해 알아보자❗

## ✨ 캐시 기본 동작

### 캐시 미사용

캐시가 없을 경우 같은 요청이 여러 번 올 때 또 계속해서 큰 용량의 파일을 보내야 한다.

- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야 한다
- 인터넷 네트워크는 매우 느리고 비싸다
- 브라우저 로딩 속도가 느리다
- 느린 사용자 경험

`cache-control: max-age=60` (초) 으로 유효 시간을 설정해 주면 캐시가 적용된다.

### 캐시 적용

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다
- 비싼 네트워크 사용량을 줄일 수 있다
- 브라우저 로딩 속도가 매우 빠르다
- 빠른 사용자 경험

만약 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다. 이때 다시 네트워크 다운로드가 발생한다.

근데 기존에 갖고 있는 데이터와 현재 들어오는 데이터가 똑같으면 다시 다운로드 받기는 너무 메모리 낭비다. 따라서, 검증 헤더와 조건부 요청을 통해 이러한 문제를 해결한다.

## ✨ 검증 헤더와 조건부 요청

- `검증 헤더` 를 통해 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요함

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
- Last-Modified, ETag

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since : Last-Modified 사용
- If-None-Match: ETag 사용
- 조건이 만족하면 200 OK
- 조건이 만족하지 않으면 304 Not Modified

### Last-Modified & If-Modified-Since

Last-Modified를 추가하면 데이터 최종 수정일을 확인할 수 있다.

### 과정

1. 클라이언트에서 서버에게 요청을 보냄
2. 서버가 클라이언트에게 Last-Modified(마지막 수정 시간)을 포함한 HTTP 응답 메시지를 전달
3. 응답 메시지를 받은 클라이언트가 응답 결과 + Last-Modified를 캐시에 저장
4. 후에 캐시가 만료되면 클라이언트가 서버에게 값을 재요청함.
   <br /> -> 만약 브라우저 캐시 (캐시 저장소)에 Last-Modified가 저장이 되어 있다면 클라이언트가 브라우저에게 재요청을 할 때 if-modified-since를 추가함.
5. 서버에서 자신의 마지막 수정 시간과 if-modified-since 값을 비교해 같다면 304 Not Modified를 **!!HTTP Body 없이!!** 보내줌

http body 없이 보낸다는 것은 서버에서 클라이언트에게 다시 파일을 보내지 않는다는 것이고, 클라이언트는 기존 캐시와 값이 같다는 것을 알았으므로 브라우저 캐시 (캐시 저장소) 에서 파일을 찾아 그대로 사용함으로써 네트워크 부하를 줄일 수 있게 되는 것이다.

검증 헤더는 Last-Modified이고, 조건부 요청은 if-modified-since이다.

참고로, 네트워크 다운로드가 발생하긴 한다. 왜냐하면 헤더를 다운로드 받아야 하기 때문에.

#### 단점

- 1초 미만 단위로 캐시 조정 불가능
- 날짜 기반 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
  <br /> ex) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우

### ETag & If-None-Match

- 캐시 제어 로직을 서버에서 완전히 관리
- 캐시용 데이터에 날짜가 아닌 임의의 고유한 버전의 이름을 달아둠
- 데이터가 변경되면 이 이름을 바꾸어 변경 (Hash 재생성)
  <br/> Hash 알고리즘을 넣어 hash를 받을 수 있음, 파일이 동일하면 해시값도 동일
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기

## ✨ 캐시와 조건부 요청 헤더

### 캐시 제어 헤더

- Cache-Control : 캐시 제어
- Pragma : 캐시 제어 (하위 호환)
- Expires : 캐시 유효 기간 (하위 호환)

### Cache-Cntrol

: 캐시 지시어

- max-age : 캐시 유효 시간, 초 단위
- no-cache : 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용 (조건부 요청 등)
- no-store : 데이터에 민감한 정보가 있으므로 저장하면 안 됨 (메모리에서 사용하고 최대한 빨리 삭제)
  <br /> -> 보통 캐시는 하드디스크에 저장됨

### Pragma

: 캐시 제어 (하위 호환)

- 별로 사용하지는 않음
- no-cache
- HTTP 1.0 하위 호환

### Expires

: 캐시 만료일 지정

- 캐시 만료일을 초 단위가 아닌 정확한 날짜로 지정
- HTTP 1.0부터 사용
- 지금은 Cache-Control: max-age 사용 권장
- Cache-Control: max-age와 함께 사용 시 Expires 무시

## ✨ 프록시 캐시

- origin 서버 직접 접근하게 되면 굉장히 느릴 수 있다. (ex, 한국에서 미국 서버에 접근, 파일 하나 다운 받는데 0.5초 이상이 걸린다)

따라서 이러한 문제를 해결하기 위해 한국 어딘가에 `프록시 캐시 서버`를 도입했다.

=> 웹 브라우저가 origin 서버에 직접 접근하는 것이 아닌, 프록시 캐시 서버를 통해 값을 받아온다.

### 기타

- public : 응답이 public 캐시에 저장되어도 됨
- private : 응답이 해당 사용자만을 위한 것 (ex, 로그인), private 캐시에 저장해야 함 (기본 값)
- s-maxage : 프록시 캐시에만 적용되는 max-age
- Age: 60 (HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내 머문 시간 (초)

## ✨ 캐시 무효화

캐시 적용을 하지 않아도 GET 요청 시 임의로 캐시를 사용하게 되므로 확실하게 캐시를 무효화하는 기능이 필요하다.

ex) 현재 사용자의 통장 잔고 등 (주기적인 업데이트 필요)

- Cache-Control : no-cache, no-store, must-revaildate
- Pragma: no-cache (HTTP 1.0 하위 호환)

네 개 다 넣어야 한다.

#### must-revaildate

- 캐시 만료 후 최초 조회 시 원 서버에 검증
- 원 서버 접근 실패 시 반드시 오류가 발생해야 함 - 504(Gateway Timeout)
- must-revaildate는 캐시 유효 시간이라면 캐시를 사용
