---
title: "[OS] Chap14-01 : 파일 시스템 구현_파일 시스템 구조"
categories:
  - OS
tags:
toc: true
toc_sticky: true
date: 2024-12-31 16:04:00 +0900
---

<strong>운영체제(Operating System Concepts) 를 읽고 정리한 정리본입니다.</strong>
{: .notice}

# 📌 Chap14-01 : 파일 시스템 구현_파일 시스템 구조

파일 시스템을 유지하기 위한 보조저장장치로 디스크가 대부분 사용된다. 이유는 다음과 같다.

1. 추가 장소를 사용하지 않고 재기록 가능
2. 디스크에 있는 임의의 블록의 정보를 직접 접근 가능

## 🫧 파일 시스템 설계

파일 시스템은 두 가지를 고려해야 한다.

1. 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의
<br/> -> 파일, 속성, 디렉터리 구조, 파일에 허용되는 연산 등을 정의

2. 논리 파일 시스템과 물리적 저장장치 간 사상하는 알고리즘과 데이터 구조 설계

## 🫧 계층적 파일 시스템

파일 시스템 설계에서 고려해야 할 두 가지 사항을 위해 계층적 파일 시스템이 설계되었다.

자세한 건 계층적 파일 시스템 설명 후 이야기할 예정이다.

모듈화, 추상화, 이식성의 장점을 들어 대부분의 파일 시스템은 계층적 파일 시스템 구조를 채택하고 있다.

파일 시스템 구현을 위해 계층 구조를 사용함으로써, 코드 중복을 최소화시킬 수 있다.

![image](https://github.com/user-attachments/assets/e2470d47-87f2-4d26-bed8-f11b03745b57)

1. 장치
2. 입출력 제어
3. 기본 파일 시스템
4. 파일-구성 모듈
5. 논리적 파일 시스템
6. 응용 프로그램

### ✨ 1. 장치

입출력이 가능한 장치. 디스크, SSD, 프린터, 스캐너, 키보드, 마우스 등이 이에 해당한다.

### ✨ 2. 입출력 제어
: 메모리와 디스크 시스템 간 통신(정보 전송)을 담당

장치 드라이버 루틴 + 인터럽트 핸들러로 구성되어 있으며, 장치 드라이버는 명령을 출력으로 변환하는 번역기이고 인터럽트 핸들러는 인터럽트가 발생했을 시 인터럽트를 처리하는 기계어 코드 루틴이다.

장치 드라이버는 블록 123을 인출하라, 와 같은 명령을 특정 하드웨어에 맞는 저수준의 명령으로 출력한다. 이렇게 나온 명령은 하드웨어 제어기에 의해 사용된다.

여기서 하드웨어 제어기는 포트나 버스나 입출력 장치를 제어하는 전자회로의 집합체이다. 즉, 입출력 장치를 시스템의 다른 부분과 접속하도록 돕는다.

장치 드라이버는 입출력 제어기 메모리의 특정 위치에 특정 비트를 설정하여 제어기에 어느 장치에 어떤 일을 수행할지 알린다.

### ✨ 3. 기본 파일 시스템 (블록 입출력 서브 시스템)

: 적절한 장치 드라이버에게 저장장치상의 블록을 읽고 쓰도록 논리 블록 주소를 기반으로 드라이브에 명령을 내린다.

즉, 기본 파일 시스템 계층에서 장치 드라이버에게 논리 블록 주소를 기반으로 명령을 내리면 입출력 제어 층에서는 이를 물리 주소로 바꿔 명령을 수행한다.

또한, 기본 파일 시스템은 다음과 같은 일을 추가적으로 수행한다.

- I/O 요청 스케줄링 고려
- 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시 관리

버퍼 내의 블록은 대용량 저장장치 블록의 전송이 일어나기 전에 할당되며, 캐시는 종종 성능 향상을 위해 파일 시스템 [1]메타데이터를 저장하는 데 사용된다.

### ✨ 4. 파일-구성 모듈

: 파일의 논리적 구조 관리

논리적 구조에는 연속 파일, 연결 리스트 파일 등이 존재한다.

해당 계층에서는 파일과 디렉터리의 실제 배치를 다룬다.

### ✨ 5. 논리적 파일 시스템

: [1] 메타데이터 정보 및 디렉터리 구조 관리

### ✨ 6. 응용 프로그램

: 파일 시스템을 사용하는 사용자 프로그램

파일의 저장, 검색, 열림 등을 요청한다.


#### ☁️ [1] 메타데이터

파일의 내용 자체인 데이터를 제외한 모든 파일 시스템 구조.

파일의 크기, 위치, 접근 권한 등의 정보가 포함되어 있다.

이는 [2] 파일 제어 블록 (FCB, file control block) 을 통해 관리된다.

#### ☁️  [2] 파일제어블록 (FCB)

소유, 허가 그리고 파일 내용의 위치를 포함하여 파일에 관한 정보를 가지고 있다.

UNIX 시스템에서는 inode로 구현한다.

### ✨ 6. 응용 프로그램

운영체제에서 실행되는 모든 소프트웨어를 뜻한다.

---

아까 전 파일 시스템 설계에서 고려해야 할 두 가지 사항을 위해 계층적 파일 시스템이 설계되었다고 했다.

1. 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의
2. 논리 파일 시스템과 물리적 저장장치 간 사상하는 알고리즘과 데이터 구조 설계

이 부분은 각각 `논리적 파일 시스템 계층`과 `파일-구성 모듈, 기본 파일 시스템, 장치 및 입출력 제어 계층` 에서 처리된다.

1. 파일 시스템이 사용자에게 어떻게 보여야 할지를 정의하는 부분은 `논리적 파일 시스템` 계층에서 처리된다.
<br/> 논리적 파일 시스템에서는 파일의 이름, 크기, 형식, 속성과 같은 메타데이터를 포함하고, 디렉터리 구조를 관리한다. 또한, 패일 생성, 읽기, 쓰기와 같은 연산을 정의한다.

2. 논리 파일 시스템과 물리적 저장장치 간 사상하는 알고리즘과 데이터 구조 설계는 파일-구성 모듈, 기본 파일 시스템, 장치 및 입출력 제어 계층에서 처리된다.

## 🫧 파일 시스템 연산 순서

응용 프로그램이 파일 시스템의 특정 연산을 실행시켰을 경우 다음과 같은 형태로 진행된다.

1. 메타데이터 탐색 (논리적 파일 시스템 계층)
<br/> -> 파일 시스템은 먼저 디렉터리 구조를 탐색하여 해당 파일의 메타데이터(FCB)를 찾는다.

2. 논리 블록 탐색 (파일-구성 모듈 계층)
<br/> -> 파일 구성 모듈은 파일의 메타데이터를 기반으로 파일이 저장된 논리 블록의 위치를 결정
<br/> -> 이 과정에서 파일 시스템은 필요한 데이터를 실제 저장 장치에서 어떻게 찾을지 결정

3. 장치 드라이버와의 상호작용 (기본 파일 시스템 계층)
<br/> -> 파일 시스템은 적절한 장치 드라이버를 선택하고 I/O 요청을 드라이버에 전달한다.

4. 버퍼 관리와 요청 처리 (기본 파일 시스템 계층)
<br/> -> 장치 드라이버는 요청을 처리하기 위한 준비를 하며, 필요한 경우 시스템 버퍼 또는 캐시를 할당하여 데이터를 임시 저장한다.

5. 연산 실행 (입출력 제어 계층, 장치 계층)
<br/> -> 장치 드라이버는 논리적 연산을 실제 장치에서 실행할 수 있는 명령으로 반환하고, 해당 명령을 스토리지 장치로 전송한다.
<br/> -> 데이터 읽기 또는 쓰기와 같은 연산이 실제로 수행된다.

6. 완료 및 응답 처리
<br/> -> 완료 상태를 응용 프로그램에게 통지, 사용 자원 정리

해당 내용은 `14.2 파일 시스템 구현`에서 더 자세하게 다룰 예정이다.

## 🫧 참고 자료
- [운영체제-입출력 시스템 | github 블로그_frontalnh](https://frontalnh.github.io/2018/04/03/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%8B%9C%EC%8A%A4%ED%85%9C/)
- [[운영체제] Part 6 - 파일 시스템::파일 시스템 구현 | velog_jeongbeom4693](https://velog.io/@jeongbeom4693/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Part-6-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%ED%98%84)