---
title: "[OS] Chap13-03 : 파일 시스템 인터페이스_디렉터리 구조"
categories:
  - File System
tags:
toc: true
toc_sticky: true
date: 2024-12-18 16:07:00 +0900
---

<strong>운영체제(Operating System Concepts) 를 읽고 정리한 정리본입니다.</strong>
{: .notice}

# 📌 Chap13-03 : 파일 시스템 인터페이스_디렉터리 구조

## 🫧 디렉터리

: 파일 이름을 상응하는 파일 제어 블록으로 바꾸어 주는 심볼 테이블

[OS Chap13-01](https://ajung7038.github.io/os/OS-Ch13-%ED%8C%8C%EC%9D%BC-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/#-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC) 에서는 디렉터리를 "서로 관련 있는 파일을 하나로 모아놓은 것" 이라 지칭하기도 했다.

## 🫧 디렉터리 연산

1. 파일 찾기
2. 파일 생성
3. 파일 삭제
4. 디렉터리 나열
5. 파일의 재명명 : 파일 이름 변경 가능
6. 파일 시스템의 순회

## 🫧 1단계 디렉터리
![image](https://github.com/user-attachments/assets/9e248fe2-634a-472f-a944-f58af9bb8be5)

- 모든 파일이 다 같이 한 개의 디렉터리 아래에 존재한다.
- 같은 디렉터리에 있는 모든 파일들은 유일한 이름을 가져야 한다.
- 파일이 많아지거나 다수의 사용자가 사용하는 시스템에서는 심각한 제약을 가지고 있다.

## 🫧 2단계 디렉터리

1단계 디렉터리에서는 다른 사용자들 사이에서의 파일 이름에 대한 혼란이 야기되었다.

이러한 문제를 해결하기 위해 2단계 디렉터리에서는 각 사용자가 서로 다른 디렉터리를 가질 수 있도록 하는 것이다.

- 각 사용자는 자신만의 UFD 디렉터리(User File Directory)를 가지고, 각 디렉터리에는 오직 한 사람의 파일만을 저장한다.

### ✨ 탐색 과정

![image](https://github.com/user-attachments/assets/f3463daa-30a9-4265-b4d7-0947faad431b)

사용자 작업이 시작되거나 시스템에 사용자가 로그인 등을 통해 접속하게 되면 탐색 과정이 시작된다.

1. 시스템이 마스터 파일 디렉터리(MFD)를 우선 탐색
<br> -> MFD는 사용자 이름이나 계정 번호로 색인되어 있고, 각 엔트리는 그 사용자의 UFD를 가리키고 있다.

2. 사용자가 특정 파일에 접근하려고 할 시 시스템은 UFD 디렉터리 밑에서만 탐색한다.

다른 디렉터리 밑에서는 파일 이름이 같아도 상관 없으므로 파일 생성 시 운영체제는 그 이름의 다른 파일이 이미 존재하는지 확인하기 위해 UFD만 검색해도 된다.

그러나 이 구조에서는 한 사용자의 UFD를 다른 사용자가 액세스할 수 없으므로 보안상 좋아보이긴 하나, 두 사용자가 한 파일을 공유해 사용해야 하는 경우 문제가 발생한다. 서로가 자신의 UFD 접근을 허용하기 전까지는 공유가 불가능하다는 것이다.

### ✨ 2단계 디렉터리에서의 경로명 (공유된 UFD)

만일 접근이 허용된다면 한 사용자가 다른 사용자의 디렉터리에 있는 파일을 지칭할 수 있어야 한다.

2단계 디렉터리에서 특정 파일을 유일하게 지칭하기 위해서는 <strong>사용자의 이름<strong>과 </strong>파일 이름</strong>을 활용해 경로명을 알아야 한다.

명령이 주어질 때마다 바뀌는 탐색 경로에 따라 일정하게 디렉터리를 탐색한다.

## 🫧 트리 구조 디렉터리

![image](https://github.com/user-attachments/assets/4bf8c9f5-6ad3-484a-9551-9e99c8c44112)


앞서 보았던 2단계 디렉터리는 2단계 트리로 보여질 수 있다. 이처럼 2단계가 아닌 여러 단계에 걸쳐 디렉터리를 나타낸 것을 트리 구조 디렉터리라고 한다.

이는 일반 사용자들에게 자신의 서브디렉터리를 얼마든 만들 수 있게 해 주며, 가장 일반적인 디렉터리 구조로도 알려져 있다.

시스템 내의 모든 파일은 고유한 경로명을 가지며, 디렉터리 또는 서브 디렉터리는 그 하부에 다시 디렉터리나 파일을 가지며 반복되는 구조이다.

추가로, 트리 구조 디렉터리에서는 자신의 파일뿐만 아니라 다른 사용자의 파일도 접근할 수 있다.

### ✨ 디렉터리 이동 (cd)

통상적으로 각 프로세스는 현재 디렉터리를 가지고 있다.

이 디렉터리는 사용자가 현재 관심이 있는 대부분의 파일이 들어 있기에 파일의 참조가 일어나면 현재 디렉터리를 먼저 검색하게 된다. 만일 현재 디렉터리에 없는 파일을 참조하려면 `cd (Change Directory)` 시스템 콜을 통해 다른 디렉터리로 바꿀 수 있다.


### ✨ 트리 구조 디렉터리에서의 경로명

1. 절대 경로명
2. 상대 경로명

#### ☁️ 절대 경로명
: UNIX와 Linux에서 절대 경로명이란 루트(첫 번째 /로 표시됨) 에서부터 지정된 파일까지의 경로가 명시된 것

#### ☁️ 상대 경로명
: 현재 디렉터리를 기준으로 목적하는 파일까지의 경로를 지정하는 것

### ✨ 트리 구조에서의 디렉터리 삭제 문제

디렉터리가 비어있다면 문제가 되지 않겠지만, 문제는 디렉터리 안 내용이 남아있는 경우이다. 이럴 경우 다음과 같은 두 가지 방법을 따른다.

1. 디렉터리 내 모든 파일을 삭제한다.
<br/>-> 만일 서브디렉터리가 존재한다면 재귀적으로 모든 파일을 삭제해 디렉터리를 비울 수 있도록 한다.

2. UNIX rm 명령어를 사용해 디렉터리와 내부의 내용까지 모두 삭제한다.
<br/>-> 전체 디렉터리가 한 번의 명령에 의해 삭제될 수 있으므로 주의를 기울여 사용해야 한다.

## 🫧 비순환 그래프 디렉터리

![image](https://github.com/user-attachments/assets/b2261eb4-cd98-4d5f-a7d1-9d8c2d5174d0)


같은 프로젝트에서 작업하고 있는 두 프로그래머를 생각해보자. 두 프로그래머 모두 관련된 파일이 자신의 디렉터리에 있기를 원한다.

프로젝트와 관련된 서브 디렉터리를 공유해야 하는 경우, 공유 디렉터리나 파일은 동시에 두 개 이상의 장소에 존재할 수 있다.

이를 비순환 그래프 디렉터리로 표현할 수 있다. 기존 트리 구조에서는 파일 또는 디렉터리의 공유를 허용하고 있지 않기 때문이다.

추가로, 디렉터리나 파일을 복사해서는 안 된다는 사실을 명심하자. 공유 파일과 복사본은 엄연히 다르다.

### ✨ 공유 파일 (공유 디렉터리) 구현 방법
1. 링크 사용
2. 파일 복사

#### ☁️ 링크 사용
- 절대 혹은 상대 경로명으로 구현이 가능하다.
- 디렉터리 검색 시 항목이 링크로 표시되어 있다면 링크를 따라 원본 파일로 접근할 수 있다.
- 링크는 간접적 포인터 역할이라고도 할 수 있다.

#### ☁️ 파일 복사
- 원본 파일을 복사해 똑같은 파일을 여러 개 두는 방식이다.
- 파일 복사 방법을 채택할 시 하나의 파일을 변경하면 동일한 복사본 항목도 함께 바뀌어야 하는 `일관성 문제` 가 일어나기 쉽다.

### ✨ 비순환 그래프 디렉터리 문제
1. 공유된 파일 중복 탐색
2. 삭제 문제

삭제 문제를 해결하기 위해 심볼릭 링크로 구현하거나 참조 계수를 활용해 모든 참조가 지워질 때까지 원본 파일을 보존하는 방법이 있다.

실제로 UNIX 운영체제에서는 하드 링크에 대해서는 파일 정보 블록에 참조 계수를 유지하면서 이러한 방식을 취하고 있다.

## 🫧 일반 그래프 디렉터리
![image](https://github.com/user-attachments/assets/6cecac65-60e4-4b4f-9efe-0c0af132fa8b)

비순환 그래프 트리 구조를 취하면서도 순환이 있는 그래프이다.

비순환 그래프의 장점인 간단한 알고리즘 (파일을 검색하고 파일에 대한 참조의 존재 여부를 결정하는 알고리즘) 과 중복 탐색 문제를 해결하기 위해 순환이 있는 비순환 그래프인 일반 그래프 디렉터리 구조를 채택한다.

### ✨ 가비지 수집 기법

가비지 컬렉션은 전체 파일 시스템을 검색하고, 접근 가능한 모든 것을 표시. 두 번째 탐색에서 표시되지 않은 것들을 수집하고 사용 가능한 공간 리스트에 추가한다.

그러나 디스크 기반의 파일 시스템에서 가비지 컬렉션은 사건아 매우 많이 드므로 좀처럼 이용되지는 않는다.