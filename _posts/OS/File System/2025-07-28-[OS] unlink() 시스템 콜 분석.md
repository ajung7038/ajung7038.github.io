---
title: "[OS] unlink() ì‹œìŠ¤í…œ ì½œ ë¶„ì„"
categories:
  - File System
tags:
toc: true
toc_sticky: true
date: 2025-07-28 15:12:00 +0900
---

<strong>[linux kernel sourse tree](https://github.com/torvalds/linux)ì˜ ê¹ƒí—ˆë¸Œ ì½”ë“œë¥¼ ì°¸ì¡°í•´ ì‹œìŠ¤í…œ ì½œ í˜¸ì¶œ ì‹œ ë³€í™” ê³¼ì •ì„ ë¶„ì„í•œ ê¸€ì…ë‹ˆë‹¤.</strong>
{: .notice}

# ğŸ“Œ unlink()

- íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì´ë¦„ê³¼ ì—°ê²°ëœ íŒŒì¼ (inode)ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ì œê±°í•˜ëŠ” ì‘ì—…
- ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ ì‚­ì œ
- ë¹ˆ ë””ë ‰í„°ë¦¬ëŠ” rmdir() ì‹œìŠ¤í…œì½œ í˜¸ì¶œë¡œ ì‚­ì œ, ì¼ë°˜ íŒŒì¼ë§Œ unlink()ë¡œ ì‚­ì œ

## ğŸ«§ ê³¼ì •

![alt text](../../../assets/image/OS/unlink().png)

1. ê²½ë¡œ í•´ì„
2. ê¶Œí•œ í™•ì¸
3. íŒŒì¼ ì‚­ì œ
4. inode í›„ì²˜ë¦¬

## ğŸ«§ íŠ¹ì§•

- ì¤‘ê°„ì— lookup() í•¨ìˆ˜ë¡œ íƒìƒ‰ì„ í•˜ë©° dentry â†’ inodeë¥¼ ì—°ê²°í•¨
    - ë§Œì•½ dentryê°€ ì´ë¯¸ ì¡´ì¬í•˜ë©´ ìºì‹œëœ dentryë¥¼ ì¬í™œìš©í•¨ (inodeê°€ ê°™ì„ ìˆ˜ë„, ë‹¤ë¥¼ ìˆ˜ë„)

## ğŸ«§ ì‚¬ìš© ì˜ˆì‹œ (ì½”ë“œ)

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char *argv[])
{
    int idx;

    if(argc == 1) {
        fprintf(stderr, "%s {file1} [file2] ...\n", argv[0]);
        return 1;
    }

    for(idx = 1; idx < argc; idx++) {
        if(unlink(argv[idx]) == -1) {
            fprintf(stderr, "%s file ì‚­ì œ error: %s\n", argv[idx], stderror(errno));
        } else {
            printf("%s fileì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.\n", argv[idx]);
        }
    }

    return 0;
}
```

## ğŸ«§ ì½”ë“œ

### âœ¨ SYSCALL_DEFINE1

- /fs/namei.c, $4644

```c
SYSCALL_DEFINE1(unlink, const char __user *, pathname)
{
	return **do_unlinkat(AT_FDCWD, getname(pathname))**;
}
```

### âœ¨ do_unlinkat()

- /fs/namei.c, $4562

```c
/*
 * Make sure that the actual truncation of the file will occur outside its
 * directory's i_mutex.  Truncate can take a long time if there is a lot of
 * writeout happening, and we don't want to prevent access to the directory
 * while waiting on the I/O.
 */
int do_unlinkat(int dfd, struct filename *name)
{
	int error;
	struct dentry *dentry;
	struct path path;
	struct qstr last;
	int type;
	struct inode *inode = NULL;
	struct inode *delegated_inode = NULL;
	unsigned int lookup_flags = 0;
retry:
	**// 1. íŒŒì¼ëª…ì„ ë¶€ëª¨ ë””ë ‰í„°ë¦¬ì™€ íŒŒì¼ëª…ìœ¼ë¡œ ë¶„ë¦¬**
	error = **filename_parentat(dfd, name, lookup_flags, &path, &last, &type)**;
	if (error)
		goto exit1;

	error = -EISDIR;
	if (type != LAST_NORM)
		goto exit2;
	
	**// 2. ì“°ê¸° ê¶Œí•œ íšë“**
	error = **mnt_want_write(path.mnt)**;
	if (error)
		goto exit2;
retry_deleg:
	**// 3. ë””ë ‰í„°ë¦¬ ë½ ë° ì‚­ì œí•  dentry íƒìƒ‰**
	// íŠ¹ì • inodeì— ëŒ€í•œ ì“°ê¸° ë½ íšë“
	inode_lock_nested(path.dentry->d_inode, I_MUTEX_PARENT);
	// ì‚­ì œí•  dentry íƒìƒ‰
	dentry = **lookup_one_qstr_excl(&last, path.dentry, lookup_flags)**;
	error = PTR_ERR(dentry);
	if (!IS_ERR(dentry)) {

		/* Why not before? Because we want correct error value */
		if (last.name[last.len] || d_is_negative(dentry))
			goto slashes;
		inode = dentry->d_inode;
		ihold(inode);
		error = security_path_unlink(&path, dentry);
		if (error)
			goto exit3;
		**// 4. ì‹¤ì œ unlink ìˆ˜í–‰**
		error = **vfs_unlink(mnt_idmap(path.mnt), path.dentry->d_inode,
				   dentry, &delegated_inode)**;
exit3:
		dput(dentry);
	}
	inode_unlock(path.dentry->d_inode);
	// i_nlink = 0ì´ ë˜ë©° trancate ë°œìƒ
	// í•„ìš” ì‹œ truncate ìˆ˜í–‰
	if (inode)
		iput(inode);	/* truncate the inode here */
	inode = NULL;
	if (delegated_inode) {
		error = break_deleg_wait(&delegated_inode);
		if (!error)
			goto retry_deleg;
	}
	mnt_drop_write(path.mnt);
exit2:
	path_put(&path);
	if (retry_estale(error, lookup_flags)) {
		lookup_flags |= LOOKUP_REVAL;
		inode = NULL;
		goto retry;
	}
exit1:
	putname(name);
	return error;

slashes:
	if (d_is_negative(dentry))
		error = -ENOENT;
	else if (d_is_dir(dentry))
		error = -EISDIR;
	else
		error = -ENOTDIR;
	goto exit3;
}
```

### âœ¨ filename_parentat()

- /fs/namei.c, $2779

```c
static int filename_parentat(int dfd, struct filename *name,
			     unsigned int flags, struct path *parent,
			     struct qstr *last, int *type)
{
	return **__filename_parentat(dfd, name, flags, parent, last, type, NULL)**;
}
```

### âœ¨ __filename_parentat()
- ì „ì²´ ê²½ë¡œë¥¼ `ë¶€ëª¨ ë””ë ‰í„°ë¦¬` + `íŒŒì¼ëª…`ìœ¼ë¡œ ë¶„ë¦¬

- /fs/namei.c, $2703

```c
/* Note: this does not consume "name" */
static int __filename_parentat(int dfd, struct filename *name,
			       unsigned int flags, struct path *parent,
			       struct qstr *last, int *type,
			       const struct path *root)
{
	int retval;
	struct nameidata nd;

	if (IS_ERR(name))
		return PTR_ERR(name);
	**// 1. nameidata êµ¬ì¡°ì²´ ì„¤ì •**
	set_nameidata(&nd, dfd, name, root);
	
	**// 2. ë¶€ëª¨ ê²½ë¡œë¡œ ì´ë™ (ê²½ë¡œ íƒìƒ‰ ì§„í–‰)**
	retval = **path_parentat(&nd, flags | LOOKUP_RCU, parent)**;
	if (unlikely(retval == -ECHILD))
		retval = path_parentat(&nd, flags, parent);
	if (unlikely(retval == -ESTALE))
		retval = path_parentat(&nd, flags | LOOKUP_REVAL, parent);
	if (likely(!retval)) {
		*last = nd.last;
		*type = nd.last_type;
		audit_inode(name, parent->dentry, AUDIT_INODE_PARENT);
	}
	restore_nameidata();
	return retval;
}
```

### âœ¨ path_parentat()
- ê²½ë¡œ íƒìƒ‰ í›„ ë¶€ëª¨ path ë°˜í™˜

- /fs/namei.c, $2687

```c
/* Returns 0 and nd will be valid on success; Returns error, otherwise. */
static int path_parentat(struct nameidata *nd, unsigned flags,
				struct path *parent)
{
	**// 1. ê²½ë¡œ ì´ˆê¸°í™” ë° íƒìƒ‰**
	const char *s = path_init(nd, flags); // open() í•¨ìˆ˜ì— ì •ë¦¬ ì™„ë£Œ
	int err = link_path_walk(s, nd); // open() í•¨ìˆ˜ì— ì •ë¦¬ë˜ì–´ ìˆìŒ
	if (!err)
	
	**// 2. RCU ì ê¸ˆ í•´ì œ, ë£¨íŠ¸ ë²”ìœ„ í™•ì¸ ë“± ê²½ë¡œ íƒìƒ‰ í›„ ì²˜ë¦¬**
		err = **complete_walk(nd**);
	if (!err) {
		**// 3. ë¶€ëª¨ path ë°˜í™˜**
		// unlink í•˜ê¸° ìœ„í•´ì„œëŠ” ë¶€ëª¨ ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ì—ì„œ í•´ë‹¹ íŒŒì¼ì„ ì‚­ì œí•´ì•¼ í•˜ë¯€ë¡œ ë¶€ëª¨ path í•„ìš”
		*parent = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}
```

### âœ¨ complete_walk()
- ê²½ë¡œ íƒìƒ‰ í›„ ë§ˆì§€ë§‰ ì²˜ë¦¬

- /fs/namei.c, $942
- RCU ì ê¸ˆ í•´ì œ, ë£¨íŠ¸ ë²”ìœ„ í™•ì¸ ë“± ê²½ë¡œ íƒìƒ‰ í›„ ì²˜ë¦¬

```c
static int complete_walk(struct nameidata *nd)
{
	struct dentry *dentry = nd->path.dentry;
	int status;

	if (nd->flags & LOOKUP_RCU) {
		/*
		 * We don't want to zero nd->root for scoped-lookups or
		 * externally-managed nd->root.
		 */
		if (!(nd->state & ND_ROOT_PRESET))
			if (!(nd->flags & LOOKUP_IS_SCOPED))
				nd->root.mnt = NULL;
		nd->flags &= ~LOOKUP_CACHED;
		if (!try_to_unlazy(nd))
			return -ECHILD;
	}

	if (unlikely(nd->flags & LOOKUP_IS_SCOPED)) {
		/*
		 * While the guarantee of LOOKUP_IS_SCOPED is (roughly) "don't
		 * ever step outside the root during lookup" and should already
		 * be guaranteed by the rest of namei, we want to avoid a namei
		 * BUG resulting in userspace being given a path that was not
		 * scoped within the root at some point during the lookup.
		 *
		 * So, do a final sanity-check to make sure that in the
		 * worst-case scenario (a complete bypass of LOOKUP_IS_SCOPED)
		 * we won't silently return an fd completely outside of the
		 * requested root to userspace.
		 *
		 * Userspace could move the path outside the root after this
		 * check, but as discussed elsewhere this is not a concern (the
		 * resolved file was inside the root at some point).
		 */
		if (!path_is_under(&nd->path, &nd->root))
			return -EXDEV;
	}

	if (likely(!(nd->state & ND_JUMPED)))
		return 0;

	if (likely(!(dentry->d_flags & DCACHE_OP_WEAK_REVALIDATE)))
		return 0;

	status = dentry->d_op->d_weak_revalidate(dentry, nd->flags);
	if (status > 0)
		return 0;

	if (!status)
		status = -ESTALE;

	return status;
}
```

### âœ¨ mnt_want_write()
- ì“°ê¸° ì‘ì—… ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸ ë° ì ê¸ˆ (ì–¸ë§ˆìš´íŠ¸ ë˜ì§€ ì•Šë„ë¡ ë³´í˜¸)

- /fs/namespace.c, $511

```c
int mnt_want_write(struct vfsmount *m)
{
	int ret;
	
	**// 1. superblock ì“°ê¸° ì‹œì‘ ì„ ì–¸ (ë½ X, countë§Œ ì¦ê°€)**
	sb_start_write(m->mnt_sb);
	**// 2. ë§ˆìš´íŠ¸ í¬ì¸íŠ¸ì— ì“°ê¸° ì ‘ê·¼ ê¶Œí•œ ìš”ì²­**
	ret = mnt_get_write_access(m);
	if (ret)
		// ì‹¤íŒ¨ ì‹œ ë¡¤ë°±
		sb_end_write(m->mnt_sb);
	return ret;
}
EXPORT_SYMBOL_GPL(mnt_want_write);
```

### âœ¨ lookup_one_qstr_excl()
- ì‚­ì œí•  dentry íƒìƒ‰

- /fs/namei.c, $1673
- dirâ†’i_opâ†’lookup() í˜¸ì¶œì„ í†µí•´ ì‹œìŠ¤í…œë³„ unlink() í•¨ìˆ˜ í˜¸ì¶œ

```c
/*
 * Parent directory has inode locked exclusive.  This is one
 * and only case when ->lookup() gets called on non in-lookup
 * dentries - as the matter of fact, this only gets called
 * when directory is guaranteed to have no in-lookup children
 * at all.
 */
struct dentry *lookup_one_qstr_excl(const struct qstr *name,
				    struct dentry *base,
				    unsigned int flags)
{
	**// 1. ë””ë ‰í„°ë¦¬ ìºì‹œì— íŒŒì¼ëª…ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸**
	struct dentry *dentry = lookup_dcache(name, base, flags);
	struct dentry *old;
	struct inode *dir = base->d_inode;

	if (dentry)
		return dentry;

	/* Don't create child dentry for a dead directory. */
	// ë¶€ëª¨ ë””ë ‰í„°ë¦¬ê°€ ì‚­ì œë˜ì—ˆê±°ë‚˜ unlinkedëœ ê²½ìš° ì˜¤ë¥˜
	if (unlikely(IS_DEADDIR(dir)))
		return ERR_PTR(-ENOENT);

	dentry = d_alloc(base, name);
	if (unlikely(!dentry))
		return ERR_PTR(-ENOMEM);

	old = **dir->i_op->lookup(dir, dentry, flags)**;
	if (unlikely(old)) {
		dput(dentry);
		dentry = old;
	}
	return dentry;
}
EXPORT_SYMBOL(lookup_one_qstr_excl);
```

```c
const struct inode_operations ext4_dir_inode_operations = {
	.create		= ext4_create,
	**.lookup		= ext4_lookup**,
	.link		= ext4_link,
	.unlink		= ext4_unlink,
	.symlink	= ext4_symlink,
	.mkdir		= ext4_mkdir,
	.rmdir		= ext4_rmdir,
	.mknod		= ext4_mknod,
	.tmpfile	= ext4_tmpfile,
	.rename		= ext4_rename2,
	.setattr	= ext4_setattr,
	.getattr	= ext4_getattr,
	.listxattr	= ext4_listxattr,
	.get_inode_acl	= ext4_get_acl,
	.set_acl	= ext4_set_acl,
	.fiemap         = ext4_fiemap,
	.fileattr_get	= ext4_fileattr_get,
	.fileattr_set	= ext4_fileattr_set,
};
```

- ext4 ë””ë ‰í„°ë¦¬ìš© inode_operations êµ¬ì¡°ì²´ì— lookup í¬í•¨. ì´ë¥¼ í† ëŒ€ë¡œ ì°¾ì•„ì„œ ext4_lookup() í•¨ìˆ˜ í˜¸ì¶œ


### âœ¨ ext4_lookup()
- dentry ì´ë¦„ -> inodeë¡œ ë§¤í•‘

- /fs/ext4/namei.c, $1788

```c
static struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)
{
	struct inode *inode;
	struct ext4_dir_entry_2 *de;
	struct buffer_head *bh;

	// ì´ë¦„ ê¸¸ì´ ì²´í¬
	if (dentry->d_name.len > EXT4_NAME_LEN)
		return ERR_PTR(-ENAMETOOLONG);

	**// 1. ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ íƒìƒ‰**
	bh = **ext4_lookup_entry(dir, dentry, &de)**;
	if (IS_ERR(bh))
		return ERR_CAST(bh);
	inode = NULL;
	if (bh) {
		__u32 ino = le32_to_cpu(de->inode);
		brelse(bh);
		if (!ext4_valid_inum(dir->i_sb, ino)) {
			EXT4_ERROR_INODE(dir, "bad inode number: %u", ino);
			return ERR_PTR(-EFSCORRUPTED);
		}
		if (unlikely(ino == dir->i_ino)) {
			EXT4_ERROR_INODE(dir, "'%pd' linked to parent dir",
					 dentry);
			return ERR_PTR(-EFSCORRUPTED);
		}
		
		**// 2. inode ì¶”ì¶œ ë° ê²€ì‚¬**
		inode = ext4_iget(dir->i_sb, ino, EXT4_IGET_NORMAL);
		if (inode == ERR_PTR(-ESTALE)) {
			EXT4_ERROR_INODE(dir,
					 "deleted inode referenced: %u",
					 ino);
			return ERR_PTR(-EFSCORRUPTED);
		}
		if (!IS_ERR(inode) && IS_ENCRYPTED(dir) &&
		    (S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)) &&
		    !fscrypt_has_permitted_context(dir, inode)) {
			ext4_warning(inode->i_sb,
				     "Inconsistent encryption contexts: %lu/%lu",
				     dir->i_ino, inode->i_ino);
			iput(inode);
			return ERR_PTR(-EPERM);
		}
	}

	if (IS_ENABLED(CONFIG_UNICODE) && !inode && IS_CASEFOLDED(dir)) {
		/* Eventually we want to call d_add_ci(dentry, NULL)
		 * for negative dentries in the encoding case as
		 * well.  For now, prevent the negative dentry
		 * from being cached.
		 */
		return NULL;
	}

	// 3. inodeì™€ dentry ì—°ê²°
	// ìºì‹œëœ dentryê°€ ìˆì„ ê²½ìš° ê·¸ê±¸ ì‚¬ìš©
	return d_splice_alias(inode, dentry);
}
```

### âœ¨ ext4_lookup_entry()
- íŠ¹ì • dentryë¥¼ ì°¾ì•„ í•´ë‹¹ inode ë²ˆí˜¸ ë“±ì˜ ì •ë³´ ì¶”ì¶œ

- /fs/ext4/namei.c, $1715

```c
static struct buffer_head *ext4_lookup_entry(struct inode *dir,
					     struct dentry *dentry,
					     struct ext4_dir_entry_2 **res_dir)
{
	int err;
	struct ext4_filename fname;
	struct buffer_head *bh;

	**// 1. ì´ë¦„ í¬ë§·**
	err = ext4_fname_prepare_lookup(dir, dentry, &fname);
	if (err == -ENOENT)
		return NULL;
	if (err)
		return ERR_PTR(err);

	**// 2. ì—”íŠ¸ë¦¬ ê²€ìƒ‰**
	bh = __ext4_find_entry(dir, &fname, res_dir, NULL);

	**// 3. í• ë‹¹ëœ ë¦¬ì†ŒìŠ¤ ì •ë¦¬**
	ext4_fname_free_filename(&fname);
	return bh;
}
```

### âœ¨ vfs_unlink()
- íŒŒì¼ ì‚­ì œ í•¨ìˆ˜

- /fs/namei.c, $4511

```c
/**
 * vfs_unlink - unlink a filesystem object
 * @idmap:	idmap of the mount the inode was found from
 * @dir:	parent directory
 * @dentry:	victim
 * @delegated_inode: returns victim inode, if the inode is delegated.
 *
 * The caller must hold dir->i_mutex.
 *
 * If vfs_unlink discovers a delegation, it will return -EWOULDBLOCK and
 * return a reference to the inode in delegated_inode.  The caller
 * should then break the delegation on that inode and retry.  Because
 * breaking a delegation may take a long time, the caller should drop
 * dir->i_mutex before doing so.
 *
 * Alternatively, a caller may pass NULL for delegated_inode.  This may
 * be appropriate for callers that expect the underlying filesystem not
 * to be NFS exported.
 *
 * If the inode has been found through an idmapped mount the idmap of
 * the vfsmount must be passed through @idmap. This function will then take
 * care to map the inode according to @idmap before checking permissions.
 * On non-idmapped mounts or if permission checking is to be performed on the
 * raw inode simply pass @nop_mnt_idmap.
 */
int vfs_unlink(struct mnt_idmap *idmap, struct inode *dir,
	       struct dentry *dentry, struct inode **delegated_inode)
{
	struct inode *target = dentry->d_inode;
	
	**// 1. ì‚­ì œ ê¶Œí•œ ê²€ì‚¬**
	int error = may_delete(idmap, dir, dentry, 0);

	if (error)
		return error;

	if (!dir->i_op->unlink)
		return -EPERM;

	**// 2. ë½ ê±¸ê¸°**
	inode_lock(target);
	if (IS_SWAPFILE(target))
		error = -EPERM;
	else if (is_local_mountpoint(dentry))
		error = -EBUSY;
	else {
		error = security_inode_unlink(dir, dentry);
		if (!error) {
			error = try_break_deleg(target, delegated_inode);
			if (error)
				goto out;
			**// 3. ì‚­ì œ**
			error = **dir->i_op->unlink(dir, dentry)**;
			if (!error) {
				dont_mount(dentry);
				detach_mounts(dentry);
			}
		}
	}
out:
	inode_unlock(target);

	/* We don't d_delete() NFS sillyrenamed files--they still exist. */
	if (!error && dentry->d_flags & DCACHE_NFSFS_RENAMED) {
		fsnotify_unlink(dir, dentry);
	} else if (!error) {
		**// 4. inode ë§í¬ ìˆ˜ ë³€ê²½ ë° í•´ë‹¹ dentry ì‚­ì œë¥¼ ì•Œë¦¼**
		fsnotify_link_count(target);
		d_delete_notify(dir, dentry);
	}

	return error;
}
EXPORT_SYMBOL(vfs_unlink);
```

### âœ¨ ext4_unlink()
- dir ë””ë ‰í„°ë¦¬ ë‚´ dentry -> d_name ì‚­ì œ í•¨ìˆ˜

- fs/ext4/namei.c, $3308

```c
static int ext4_unlink(struct inode *dir, struct dentry *dentry)
{
	int retval;

	if (unlikely(ext4_forced_shutdown(dir->i_sb)))
		return -EIO;

	trace_ext4_unlink_enter(dir, dentry);
	/*
	 * Initialize quotas before so that eventual writes go
	 * in separate transaction
	 */
	retval = dquot_initialize(dir);
	if (retval)
		goto out_trace;
	retval = dquot_initialize(d_inode(dentry));
	if (retval)
		goto out_trace;

	retval = **__ext4_unlink(dir, &dentry->d_name, d_inode(dentry), dentry)**;

	/* VFS negative dentries are incompatible with Encoding and
	 * Case-insensitiveness. Eventually we'll want avoid
	 * invalidating the dentries here, alongside with returning the
	 * negative dentries at ext4_lookup(), when it is  better
	 * supported by the VFS for the CI case.
	 */
	if (IS_ENABLED(CONFIG_UNICODE) && IS_CASEFOLDED(dir))
		d_invalidate(dentry);

out_trace:
	trace_ext4_unlink_exit(dentry, retval);
	return retval;
}
```

### âœ¨ __ext4_unlink()
- dentry ê²€ìƒ‰ ë° ì œê±°, inode ë³€ê²½ì‚¬í•­ ê¸°ë¡

- fs/ext4/namei.c, $3235

```c
int __ext4_unlink(struct inode *dir, const struct qstr *d_name,
		  struct inode *inode,
		  struct dentry *dentry /* NULL during fast_commit recovery */)
{
	int retval = -ENOENT;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	handle_t *handle;
	int skip_remove_dentry = 0;

	/*
	 * Keep this outside the transaction; it may have to set up the
	 * directory's encryption key, which isn't GFP_NOFS-safe.
	 */
	 
	**// 1. dentry ê²€ìƒ‰**
	bh = ext4_find_entry(dir, d_name, &de, NULL);
	if (IS_ERR(bh))
		return PTR_ERR(bh);

	if (!bh)
		return -ENOENT;

	**// 2. ì°¾ì€ ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ì˜ inodeì™€ ì‚­ì œ ëŒ€ìƒ inodeê°€ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì‚¬**
	if (le32_to_cpu(de->inode) != inode->i_ino) {
		/*
		 * It's okay if we find dont find dentry which matches
		 * the inode. That's because it might have gotten
		 * renamed to a different inode number
		 */
		
		if (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY)
			skip_remove_dentry = 1;
		else
			goto out_bh;
	}
	
	**// 3. ì €ë„ íŠ¸ëœì­ì…˜ ì‹œì‘**
	handle = ext4_journal_start(dir, EXT4_HT_DIR, // ë¶„ì„í•˜ê³  ì‹¶ì—ˆìœ¼ë‚˜ ì‹œê°„ì´ ë¶€ì¡±í•´..
				    EXT4_DATA_TRANS_BLOCKS(dir->i_sb));
	if (IS_ERR(handle)) {
		retval = PTR_ERR(handle);
		goto out_bh;
	}

	if (IS_DIRSYNC(dir))
		ext4_handle_sync(handle);

	if (!skip_remove_dentry) {
		**// 4. ë””ë ‰í„°ë¦¬ ì—”íŠ¸ë¦¬ ì œê±°**
		retval = **ext4_delete_entry(handle, dir, de, bh)**;
		if (retval)
			goto out_handle;
		inode_set_mtime_to_ts(dir, inode_set_ctime_current(dir));
		ext4_update_dx_flag(dir);
		retval = ext4_mark_inode_dirty(handle, dir);
		if (retval)
			goto out_handle;
	} else {
		retval = 0;
	}
	**// 5. ë§í¬ -- ë° orphan ì²˜ë¦¬**
	if (inode->i_nlink == 0)
		ext4_warning_inode(inode, "Deleting file '%.*s' with no links",
				   d_name->len, d_name->name);
	else
		drop_nlink(inode);
	if (!inode->i_nlink)
		ext4_orphan_add(handle, inode);
	inode_set_ctime_current(inode);
	
	**// 6. inode ë³€ê²½ ì‚¬í•­ ê¸°ë¡ (ì €ë„ì— ë°˜ì˜)**
	retval = ext4_mark_inode_dirty(handle, inode);
	if (dentry && !retval)
		ext4_fc_track_unlink(handle, dentry);
out_handle:
	ext4_journal_stop(handle);
out_bh:
	brelse(bh);
	return retval;
}
```

### âœ¨ ext4_delete_entry()
- dentry ì œê±° ë° inode=0 ì„¸íŒ…

- /fs/ext4/namei.c, $2721

```c
static int ext4_delete_entry(handle_t *handle,
			     struct inode *dir,
			     struct ext4_dir_entry_2 *de_del,
			     struct buffer_head *bh)
{
	int err, csum_size = 0;

	**// 1. lnline ë°ì´í„° ì²˜ë¦¬ (inodeì— ë””ë ‰í„°ë¦¬ ì €ì¥)**
	if (ext4_has_inline_data(dir)) {
		int has_inline_data = 1;
		err = ext4_delete_inline_entry(handle, dir, de_del, bh,
					       &has_inline_data);
		if (has_inline_data)
			return err;
	}

	if (ext4_has_metadata_csum(dir->i_sb))
		csum_size = sizeof(struct ext4_dir_entry_tail);

	BUFFER_TRACE(bh, "get_write_access");
		**// 2. ë¸”ë¡ì— ëŒ€í•œ ì“°ê¸° ê¶Œí•œì„ ì €ë„ì— ìš”ì²­**
		// ì‹¤íŒ¨ ì‹œ ìˆ˜ì • ë¶ˆê°€
	err = ext4_journal_get_write_access(handle, dir->i_sb, bh,
					    EXT4_JTR_NONE);
	if (unlikely(err))
		goto out;

	**// 3. ì—”íŠ¸ë¦¬ ì œê±° (inode = 0)**
	err = ext4_generic_delete_entry(dir, de_del, bh, bh->b_data,
					dir->i_sb->s_blocksize, csum_size);
	if (err)
		goto out;

	BUFFER_TRACE(bh, "call ext4_handle_dirty_metadata");
	err = ext4_handle_dirty_dirblock(handle, dir, bh);
	if (unlikely(err))
		goto out;

	return 0;
out:
	if (err != -ENOENT)
		ext4_std_error(dir->i_sb, err);
	return err;
}
```

## ğŸ«§ ì°¸ê³  ìë£Œ

- [ì½”ë“œ ì‚¬ìš© ì˜ˆì œ](https://www.it-note.kr/177)