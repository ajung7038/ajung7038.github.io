---
title: "[OS] write() ì‹œìŠ¤í…œ ì½œ ë¶„ì„"
categories:
  - File System
tags:
toc: true
toc_sticky: true
date: 2025-07-28 15:19:00 +0900
---

<strong>[linux kernel sourse tree](https://github.com/torvalds/linux)ì˜ ê¹ƒí—ˆë¸Œ ì½”ë“œë¥¼ ì°¸ì¡°í•´ ì‹œìŠ¤í…œ ì½œ í˜¸ì¶œ ì‹œ ë³€í™” ê³¼ì •ì„ ë¶„ì„í•œ ê¸€ì…ë‹ˆë‹¤.</strong>
{: .notice}

# ğŸ“Œ write()

- open() ì‹œìŠ¤í…œ ì½œë¡œ íšë“í•œ file descriptorì„ í†µí•´ ë°ì´í„°ë¥¼ ê¸°ë¡í•˜ëŠ” ë° ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜
- íŒŒì¼ì— ë°ì´í„°ë¥¼ ì“°ê±°ë‚˜, í‘œì¤€ ì¶œë ¥ìœ¼ë¡œ ë°ì´í„° ì¶œë ¥ ì‹œ ì‚¬ìš©

## ğŸ«§ ê³¼ì •
![alt text](../../../assets/image/OS/write().png)

1. ì˜¤í”„ì…‹ ê²€ì‚¬
2. ê¶Œí•œ ê²€ì‚¬ ë° ì˜ì—­ ìœ íš¨ì„± ê²€ì‚¬
3. ì“°ê¸° ë°©ì‹ì— ë”°ë¼ ì“°ê¸° ì‘ì—… ìˆ˜í–‰

## ğŸ«§ íŠ¹ì§•

- ext4_buffered_write_iter()ì—ì„œëŠ” ë¹„ë™ê¸°ì ìœ¼ë¡œ ì§€ì› X

## ğŸ«§ ì‚¬ìš© ì˜ˆì‹œ (ì½”ë“œ)

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
 
int main() {
    int fd = open("TEXT", O_RDWR | O_CREAT, 0666);
    if(fd == -1) {
        fprintf(stderr, "Failed to open file.\n");
        exit(0);
    }
 
    const char *buf = "Welcome to VALLHALLA!\n";
 
    // writes buf --> fd
    ssize_t nr = **write(fd, buf, strlen(buf))**;
    if(nr == -1) {
        fprintf(stderr, "Failed to write file.\n");
        exit(0);
    }
    else printf("Writing Success!\n");
 
    return 0;
}
```

## ğŸ«§ ì½”ë“œ

### âœ¨ SYSCALL_DEFINE3

- fs/namei.c, $739

```c
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
		size_t, count)
{
	return **ksys_write(fd, buf, count)**;
}
```

### âœ¨ ksys_write()

- ì˜¤í”„ì…‹ í™•ì¸ í›„ open() í•¨ìˆ˜ í˜¸ì¶œ
- fs/namei.c, $720

```c
ssize_t ksys_write(unsigned int fd, const char __user *buf, size_t count)
{
	CLASS(fd_pos, f)(fd);
	ssize_t ret = -EBADF;

	if (!fd_empty(f)) {
		**// 1. í˜„ì¬ íŒŒì¼ì˜ ì˜¤í”„ì…‹ ê°€ì ¸ì˜¤ê¸°**
		loff_t pos, *ppos = file_ppos(fd_file(f));
		if (ppos) {
			pos = *ppos;
			ppos = &pos;
		}
		
		**// 2. ext4_open() í•¨ìˆ˜ë¡œ ìœ„ì„**
		ret = **vfs_write(fd_file(f), buf, count, ppos)**;
		if (ret >= 0 && ppos)
			fd_file(f)->f_pos = pos;
	}

	return ret;
}
```

### âœ¨ vfs_write()
- ê¶Œí•œ ê²€ì‚¬ ë° ext4 ì“°ê¸° í•¨ìˆ˜ í˜¸ì¶œ
- fs/read_write.c, $659

```c

ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
{
	ssize_t ret;

	**// 1. ê¶Œí•œ ê²€ì‚¬**
	if (!(file->f_mode & FMODE_WRITE))
		return -EBADF;
	if (!(file->f_mode & FMODE_CAN_WRITE))
		return -EINVAL;
	**// ì‚¬ìš©ì ê³µê°„ ì ‘ê·¼ ê°€ëŠ¥ì„± í™•ì¸**
	if (unlikely(!access_ok(buf, count)))
		return -EFAULT;

	**// íŒŒì¼ ì˜¤í”„ì…‹ ë“± ì˜ì—­ì´ ìœ íš¨í•œì§€ í™•ì¸**
	ret = rw_verify_area(WRITE, file, pos, count);
	if (ret)
		return ret;
	if (count > MAX_RW_COUNT)
		count =  MAX_RW_COUNT;
		
	**// 2. ì“°ê¸° ì‘ì—… ì„ ì–¸**
	file_start_write(file);
	if (file->f_op->write)
		ret = **file->f_op->write(file, buf, count, pos)**;
	else if (file->f_op->write_iter)
		ret = new_sync_write(file, buf, count, pos);
	else
		ret = -EINVAL;
	if (ret > 0) {
		fsnotify_modify(file);
		add_wchar(current, ret);
	}
	inc_syscw(current);
	file_end_write(file);
	return ret;
}
```

### âœ¨ ext4_file_write_iter()

- ì“°ê¸° ë°©ì‹ì— ë”°ë¥¸ ê°ê¸° ë‹¤ë¥¸ í•¨ìˆ˜ í˜¸ì¶œ (DAX, DIO, Buffer)
- /fs/ext4/file.c, $688

```c
static ssize_t
ext4_file_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	struct inode *inode = file_inode(iocb->ki_filp);

	if (unlikely(ext4_forced_shutdown(inode->i_sb)))
		return -EIO;

#ifdef CONFIG_FS_DAX
	if (IS_DAX(inode))
		return ext4_dax_write_iter(iocb, from);
#endif

	if (iocb->ki_flags & IOCB_ATOMIC) {
		size_t len = iov_iter_count(from);
		int ret;

		if (len < EXT4_SB(inode->i_sb)->s_awu_min ||
		    len > EXT4_SB(inode->i_sb)->s_awu_max)
			return -EINVAL;

		ret = generic_atomic_write_valid(iocb, from);
		if (ret)
			return ret;
	}

	if (iocb->ki_flags & IOCB_DIRECT)
		return **ext4_dio_write_iter(iocb, from)**;
	else
		return **ext4_buffered_write_iter(iocb, from)**;
}
```

- DAX : Direct Access (ì‚¬ìš©ì ë²„í¼ â†’ ì¥ì¹˜ ë©”ëª¨ë¦¬)
- DIO : Direct I/O (ì‚¬ìš©ì ë²„í¼ â†’ ë¸”ë¡ ë””ë°”ì´ìŠ¤)
- Buffered I/O : ì¼ë°˜ íŒŒì¼ ì“°ê¸° (ì‚¬ìš©ì ë²„í¼ â†’ í˜ì´ì§€ ìºì‹œ â†’ ì¶”í›„ì— ë””ìŠ¤í¬ ì“°ê¸° ì§„í–‰)

### âœ¨ ext4_dio_write_iter()

- Direct I/O ì‘ì—…ì—ì„œì˜ write() ì‹œìŠ¤í…œ ì½œ ì²˜ë¦¬
- /fs/ext4/file.c, $499

```c
static ssize_t ext4_dio_write_iter(struct kiocb *iocb, struct iov_iter *from)
{
	ssize_t ret;
	handle_t *handle;
	struct inode *inode = file_inode(iocb->ki_filp);
	loff_t offset = iocb->ki_pos;
	size_t count = iov_iter_count(from);
	const struct iomap_ops *iomap_ops = &ext4_iomap_ops;
	bool extend = false, unwritten = false;
	bool ilock_shared = true;
	int dio_flags = 0;

	/*
	 * Quick check here without any i_rwsem lock to see if it is extending
	 * IO. A more reliable check is done in ext4_dio_write_checks() with
	 * proper locking in place.
	 */
	if (offset + count > i_size_read(inode))
		ilock_shared = false;

	if (iocb->ki_flags & IOCB_NOWAIT) {
		if (ilock_shared) {
			if (!inode_trylock_shared(inode))
				return -EAGAIN;
		} else {
			if (!inode_trylock(inode))
				return -EAGAIN;
		}
	} else {
		if (ilock_shared)
			inode_lock_shared(inode);
		else
			inode_lock(inode);
	}

	/* Fallback to buffered I/O if the inode does not support direct I/O. */
	if (!ext4_should_use_dio(iocb, from)) {
		if (ilock_shared)
			inode_unlock_shared(inode);
		else
			inode_unlock(inode);
		return ext4_buffered_write_iter(iocb, from);
	}

	/*
	 * Prevent inline data from being created since we are going to allocate
	 * blocks for DIO. We know the inode does not currently have inline data
	 * because ext4_should_use_dio() checked for it, but we have to clear
	 * the state flag before the write checks because a lock cycle could
	 * introduce races with other writers.
	 */
	ext4_clear_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA);

	ret = ext4_dio_write_checks(iocb, from, &ilock_shared, &extend,
				    &unwritten, &dio_flags);
	if (ret <= 0)
		return ret;

	offset = iocb->ki_pos;
	count = ret;

	if (extend) {
		handle = ext4_journal_start(inode, EXT4_HT_INODE, 2);
		if (IS_ERR(handle)) {
			ret = PTR_ERR(handle);
			goto out;
		}

		ret = ext4_orphan_add(handle, inode);
		ext4_journal_stop(handle);
		if (ret)
			goto out;
	}

	if (ilock_shared && !unwritten)
		iomap_ops = &ext4_iomap_overwrite_ops;
	ret = iomap_dio_rw(iocb, from, iomap_ops, &ext4_dio_write_ops,
			   dio_flags, NULL, 0);
	if (ret == -ENOTBLK)
		ret = 0;
	if (extend) {
		/*
		 * We always perform extending DIO write synchronously so by
		 * now the IO is completed and ext4_handle_inode_extension()
		 * was called. Cleanup the inode in case of error or race with
		 * writeback of delalloc blocks.
		 */
		WARN_ON_ONCE(ret == -EIOCBQUEUED);
		ext4_inode_extension_cleanup(inode, ret < 0);
	}

out:
	if (ilock_shared)
		inode_unlock_shared(inode);
	else
		inode_unlock(inode);

	if (ret >= 0 && iov_iter_count(from)) {
		ssize_t err;
		loff_t endbyte;

		/*
		 * There is no support for atomic writes on buffered-io yet,
		 * we should never fallback to buffered-io for DIO atomic
		 * writes.
		 */
		WARN_ON_ONCE(iocb->ki_flags & IOCB_ATOMIC);

		offset = iocb->ki_pos;
		err = ext4_buffered_write_iter(iocb, from);
		if (err < 0)
			return err;

		/*
		 * We need to ensure that the pages within the page cache for
		 * the range covered by this I/O are written to disk and
		 * invalidated. This is in attempt to preserve the expected
		 * direct I/O semantics in the case we fallback to buffered I/O
		 * to complete off the I/O request.
		 */
		ret += err;
		endbyte = offset + err - 1;
		err = filemap_write_and_wait_range(iocb->ki_filp->f_mapping,
						   offset, endbyte);
		if (!err)
			invalidate_mapping_pages(iocb->ki_filp->f_mapping,
						 offset >> PAGE_SHIFT,
						 endbyte >> PAGE_SHIFT);
	}

	return ret;
}
```

### âœ¨ ext4_buffered_write_iter()

- fs/ext4/file.c, $285

```c
static ssize_t ext4_buffered_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	ssize_t ret;
	struct inode *inode = file_inode(iocb->ki_filp);

	if (iocb->ki_flags & IOCB_NOWAIT)
		return -EOPNOTSUPP;

	// 1. inode lock íšë“
	inode_lock(inode);
	ret = ext4_write_checks(iocb, from);
	if (ret <= 0)
		goto out;

	// 2. ì“°ê¸° ì‘ì—… ìˆ˜í–‰
	ret = generic_perform_write(iocb, from);

out:
	inode_unlock(inode);
	if (unlikely(ret <= 0))
		return ret;
	return **generic_write_sync(iocb, ret)**;
}
```

### âœ¨ generic_write_sync()

- ì“°ê¸° í•¨ìˆ˜ (ë™ê¸°ì‹ ì“°ê¸° ìš”ì²­ì¼ ê²½ìš° flushê¹Œì§€ ìˆ˜í–‰)
- /linux/fs.h, $2901

```c
/*
 * Sync the bytes written if this was a synchronous write.  Expect ki_pos
 * to already be updated for the write, and will return either the amount
 * of bytes passed in, or an error if syncing the file failed.
 */
static inline ssize_t generic_write_sync(struct kiocb *iocb, ssize_t count)
{
	if (iocb_is_dsync(iocb)) {
		int ret = vfs_fsync_range(iocb->ki_filp,
				iocb->ki_pos - count, iocb->ki_pos - 1,
				(iocb->ki_flags & IOCB_SYNC) ? 0 : 1);
		if (ret)
			return ret;
	}

	return count;
}
```

### âœ¨ ext4_write_begin()
- /fs/ext4/inode.c, $1140

```c
static int ext4_write_begin(struct file *file, struct address_space *mapping,
			    loff_t pos, unsigned len,
			    struct folio **foliop, void **fsdata)
{
	struct inode *inode = mapping->host;
	int ret, needed_blocks;
	handle_t *handle;
	int retries = 0;
	struct folio *folio;
	pgoff_t index;
	unsigned from, to;

	if (unlikely(ext4_forced_shutdown(inode->i_sb)))
		return -EIO;

	trace_ext4_write_begin(inode, pos, len);
	/*
	 * Reserve one block more for addition to orphan list in case
	 * we allocate blocks but write fails for some reason
	 */
	needed_blocks = ext4_writepage_trans_blocks(inode) + 1;
	index = pos >> PAGE_SHIFT;
	from = pos & (PAGE_SIZE - 1);
	to = from + len;

	if (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {
		ret = ext4_try_to_write_inline_data(mapping, inode, pos, len,
						    foliop);
		if (ret < 0)
			return ret;
		if (ret == 1)
			return 0;
	}

	/*
	 * __filemap_get_folio() can take a long time if the
	 * system is thrashing due to memory pressure, or if the folio
	 * is being written back.  So grab it first before we start
	 * the transaction handle.  This also allows us to allocate
	 * the folio (if needed) without using GFP_NOFS.
	 */
retry_grab:
	folio = __filemap_get_folio(mapping, index, FGP_WRITEBEGIN,
					mapping_gfp_mask(mapping));
	if (IS_ERR(folio))
		return PTR_ERR(folio);
	/*
	 * The same as page allocation, we prealloc buffer heads before
	 * starting the handle.
	 */
	if (!folio_buffers(folio))
		create_empty_buffers(folio, inode->i_sb->s_blocksize, 0);

	folio_unlock(folio);

retry_journal:

	**// 1. ì €ë„ ê¸°ë¡ ì‹œì‘**
	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);
	if (IS_ERR(handle)) {
		folio_put(folio);
		return PTR_ERR(handle);
	}

	folio_lock(folio);
	if (folio->mapping != mapping) {
		/* The folio got truncated from under us */
		folio_unlock(folio);
		folio_put(folio);
		ext4_journal_stop(handle);
		goto retry_grab;
	}
	/* In case writeback began while the folio was unlocked */
	folio_wait_stable(folio);

	if (ext4_should_dioread_nolock(inode))
		**// 2. ì“°ê¸°ë¥¼ ìœ„í•œ ë°ì´í„° ë¸”ë¡ í• ë‹¹**
		ret = ext4_block_write_begin(handle, folio, pos, len,
					     ext4_get_block_unwritten);
	else
		ret = ext4_block_write_begin(handle, folio, pos, len,
					     ext4_get_block);
	if (!ret && ext4_should_journal_data(inode)) {
		
		**// 3. ë¸”ë¡ë“¤ì„ ì €ë„ì— ë“±ë¡**
		ret = ext4_walk_page_buffers(handle, inode,
					     folio_buffers(folio), from, to,
					     NULL, do_journal_get_write_access);
	}

	if (ret) {
		bool extended = (pos + len > inode->i_size) &&
				!ext4_verity_in_progress(inode);

		folio_unlock(folio);
		/*
		 * ext4_block_write_begin may have instantiated a few blocks
		 * outside i_size.  Trim these off again. Don't need
		 * i_size_read because we hold i_rwsem.
		 *
		 * Add inode to orphan list in case we crash before
		 * truncate finishes
		 */
		if (extended && ext4_can_truncate(inode))
			ext4_orphan_add(handle, inode);

		ext4_journal_stop(handle);
		if (extended) {
			ext4_truncate_failed_write(inode);
			/*
			 * If truncate failed early the inode might
			 * still be on the orphan list; we need to
			 * make sure the inode is removed from the
			 * orphan list in that case.
			 */
			if (inode->i_nlink)
				ext4_orphan_del(NULL, inode);
		}

		if (ret == -ENOSPC &&
		    ext4_should_retry_alloc(inode->i_sb, &retries))
			goto retry_journal;
		folio_put(folio);
		return ret;
	}
	*foliop = folio;
	return ret;
}
```
